## Структура проекта

SATURN_automatisation/
├── .env                                # файл с переменными 
├── requirements.txt                    # требования для окружения проекта
├── README.md                  
├── notebooks/
│   ├── Invoice_reciving.ipynb          # блокнот с описанием приемки входящих инвойсов
    ├── Invoice_creation.ipynb          # блокнот с описанием создания накладных в розницу
├── services/                           # директория с сервисами
│   ├── sending_retail.py               # сервис отправки в розницу
│   ├── reciving_inv.py                 # сервис приемки инвойсов
│   ├── invoice_service.log             # логирование приемки
│   ├── Dockerfile_sent_retail          # докер файл для сервиса отправки в розницу
│   ├── requirements_services.txt       # требования для докеризации
│   ├── results/                        # для результатов 
│   └── logs/                           # для логов 
├── .gitignore                          # исключения при коммитах в git 


## Вводная информация

Есть довольно подробная документация по SEAPI:
https://wiki.fgis-saturn.ru/hs/5._%D0%94%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F_%D0%BF%D0%BE_SE-API

Тут скорее приведен ряд налюдений из собственного опыта взаимодействия и вычитки телеграмм канала https://t.me/+BCDeNbIaEpVhZDIy

**SEAPI**
Хотя Оператор и Разработчик системы даже прямо писали что это никакой не REST по сути все равно API создано по архитектуре REST, но есть отличия (маниакальные особенности разработчика):
- URL для всех случаев жизни всегда один
  для прода это https://api.fgis-saturn.ru/probeInnerArm/innerArm/seapi/  
  для песочницы это https://demo-hs.fgis-saturn.ru/probeInnerArm/innerArm/seapi/

- **payload** содержит параметры которые передаются в вызываемые функции (операции):

```
payload = {
    "otype": "WarehouseStates",
    "com": "execOperation",
    "op": "static/getTotals()",
    "opargs": {
"theCard": {
"dateTime": "2025-12-05T11:17:36+03:00",
"groupBy": "pat"
}
}
}

```
ниже укажу какие бывают параметры.

- возвращает в ответе SEAPI не JSON, а HRJSON, по сути тот же JSON с парой "ключ":"значение", со списками {} и массивами [], но есть разница, во первых допускает комментарии, во вторых несколько иначе записывается, ниже сравнение строк:

* JSON строка "vetis_region": Null -- двойные кавычки, допускается только Null, никаких NaN и None
* HRJSON строка 'vetis_region': None -- одинарные кавычки, допускается None

В общем обычные плагины эту штуку не приймут, но например в python с ним вполне работают стандартные библиотеки для JSON, в блокноте видно, можно поиграться.

**Набор параметров, описывающих вызываемые API - команды**

- **com** - команда API, которую надо выполнить:
  - **getRegisteredEtityNames** – получить имена сущностей;
  - **getEtityMD** - получить метаданные сущности (для каждой табличной части сущности надо делать отдельный запрос);
  - **getEtityLCNames** - отдать имена допустимых ЖЦ;
  - **getEtityLC** - получить описание ЖЦ сущности, по имени ЖЦ (все состояния и все операции всех состояний);
  - **getEntityStates** – получить состояния сущности, по всем ЖЦ, которые допустимы у сущности;
  - **getAllowedEntityOpereations** - получить перечень допустимых операций для заданной сущности;
  - **execOperation** - выполнение операции ЖЦ сущности (выполняется по умолчанию);
- **otype** - имя класса сущности (необходимо при выполнении команды, касающиеся класса или объекта сущности);
- **op** - имя операции ЖЦ, вызываемой у сущности (тип операции указан в otype, идентификатор – в oid);
- **opargs** - строка в формате JSON-объекта с аргументами операции; (аргументы описаны в описании операций);
- **oid** - идентификатор сущности в Системе (он же - идентификатор записи в БД). Указывается, если выполняется команда над объектом Системы.

**ВНИМАНИЕ** время для этого поделия указывается по ISO 8601 с указанием зоны (или с суффиксом `Z`), ели указать без смещения (`+03:00` или `Z`)  валидатор считает его некорректным и вернет 500
Пример **"2025-12-05T11:17:36+03:00"**


## Правила авторизации и получения Acces токена

На проде для того чтобы первый раз получить пару Access token & Refresh token нужно пройти по ссылке:
для продуктива https://api.fgis-saturn.ru/login и авторизоваться через Госуслуги (работодатель должен дать "привязку" в акаунте для компании).

для песочницы https://demo-hs.fgis-saturn.ru/login

Зачем нужна пара токенов:

Рефреш токен (Refresh Token) — это специальный токен, который используется для получения нового токена доступа (Access Token) без необходимости повторной аутентификации пользователя. Он играет ключевую роль в механизме авторизации и аутентификации в приложениях

Как работает рефреш токен

Выдача токенов: Когда пользователь успешно авторизуется, сервер выдает ему две вещи: Access Token и Refresh Token. Access Token используется для доступа к защищенным ресурсам и имеет короткий срок жизни (обычно от нескольких минут до часов). Refresh Token, наоборот, живет дольше и используется для обновления пары токенов.
Обновление токенов: Когда Access Token истекает, клиент отправляет Refresh Token на сервер для получения новой пары токенов. Сервер проверяет валидность и срок действия Refresh Token, а затем генерирует новый Access Token и новый Refresh Token.
Хранение Refresh Token: Refresh Token обычно хранится на клиенте и в базе данных сервера. Это необходимо для проверки валидности токена при обновлении.
Обновление Refresh Token: При обновлении токенов Refresh Token также обновляется. Это делается для того, чтобы предотвратить бесконечное использование одного и того же Refresh Token и для повышения безопасности.
Нужно 1 раз зайти на веб форму для получения рефрэш токена в первый раз. Далее при отправке GET запроса на эндпоинт сервер будет возвращать пару рефреш и аксесс токенов.

* Вызов для обновления, а также ряд примеров показан в блокноте Some_samples.ipynb

**Время жизни access токена 14 дней Время жизни refresh токена 28 дней**

## Фильтрация

При API запросе в payload (правда не везде, но об этом подробнее можно почитать в доке) можно устанавливать фильтры (и это ценно), например:
```
payload = {
  "com": "execOperation",
  "op": "static/getList()",
  "otype": "Contractor",
  "opargs":{
    "pos": 0,
    "size": 10,
    "getFullCards": 1,
    "filters": [
      {
        "column": "inn",
        "condition": "=",
        "value": [5029069967]
      },
      { "column": "lcState",
       "condition": "=", 
       "value": ["actual"] 
      }
    ]
  }
}

```

Можно формировать и более интересные условия, например  >= и <= 

```

{
  "pos": 0,
  "size": 10,
  "orderBy" : ["id"],
  "getFullCards": 1,
  "filters": [
    {
      "condition": "and",
      "filters": [
        {
          "column": "id",
          "condition": ">=",
          "value": [
            "400000"
          ]
        },
        {
          "column": "id",
          "condition": "<=",
          "value": [
            "500000"
          ]
        }
      ]
    }
  ]
}

```

## Сервис для принятия на склад всех накладных в статусе "В пути" (onWay)

Сам сервис в файле reciving_inv.py

Как происходят вызовы и сама логика описана в блокноте Invoice_reciving.ipynb

Запускается сервис командой
```python reciving_inv.py
```
Логи выводятся в консоль и сохраняются в файле invoice_service.log

## Сервис для поиска остатков и формрования накладных на списание в розницу

Сам сервис в файле sending_retail.py

Логика сервиса описана в блокноте Invoice_creation.ipynb

Возможен тестовый прогон результатом которого будут сформированыые накладные без реальной отправки в САТУРН.

**Тестовый прогон (по умолчанию - 2 накладные по 2 позиции)**
```python sending_retail.py
```
**Реальная отправка с параметрами по умолчанию**
```python sending_retail.py --execute
```

**Реальная отправка с другими параметрами**
```python sending_retail.py --execute --limit 5 --items 1
```

**Реальная отправка без ограничений (осторожно!)**
```python sending_retail.py --execute --no-limit
```

**Тестовый прогон с другими параметрами**
```sending_retail.py --limit 3 --items 4
```